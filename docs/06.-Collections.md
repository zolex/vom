[![Release](https://github.com/zolex/vom/workflows/Release/badge.svg)](https://github.com/zolex/vom/actions/workflows/release.yaml)
[![Version](https://img.shields.io/packagist/v/zolex/vom)](https://packagist.org/packages/zolex/vom)
[![Integration](https://github.com/zolex/vom/workflows/Integration/badge.svg)](https://github.com/zolex/vom/actions/workflows/integration.yaml)
[![Code Coverage](https://codecov.io/gh/zolex/vom/graph/badge.svg?token=RI2NX4S89I)](https://codecov.io/gh/zolex/vom)
[![License](https://img.shields.io/packagist/l/zolex/vom)](./LICENSE)
[![Downloads](https://img.shields.io/packagist/dt/zolex/vom)](https://packagist.org/packages/zolex/vom)

![VOM](https://raw.githubusercontent.com/zolex/vom/refs/heads/master/docs/logo.png)

![PHP](https://img.shields.io/badge/php-%23777BB4.svg?style=for-the-badge&logo=php&logoColor=white)
![Symfony](https://img.shields.io/badge/symfony-%23000000.svg?style=for-the-badge&logo=symfony&logoColor=white)
![Laravel](https://img.shields.io/badge/laravel-%23FF2D20.svg?style=for-the-badge&logo=laravel&logoColor=white)


The Versatile Object Mapper - or in short VOM - is a PHP library to transform any data structure into strictly typed models (and back) by adding PHP 8 attributes.
It extends symfony/serializer functionality and is heavily inspired by doctrine and API-Platform, so that advanced mappings can simply be defined on the model classes instead of writing normalizer decorators.

## Topic Overview

[00. Installation and Integration](00.-Installation-and-Integration.md#installation-and-integration) \
[01. The ObjectMapper](01.-The-Object-Mapper.md#the-object-mapper) \
[02. Property Attribute](02.-Property-Attribute.md#the-property-attribute) \
[03. Disable Nesting](03.-Disable-Nesting.md#disable-nesting) \
[04. Root and Relative Accessor](04.-Root-and-Relative-Accessor.md#root-and-relative-accessor) \
[05. Data Types](05.-Data-Types.md#data-types) \
[06. Collections](06.-Collections.md#collections) \
[07. Constructor Arguments](07.-Constructor-Arguments.md#constructor-arguments) \
[08. Factories](08.-Factories.md#factories) \
[09. Denormalizer Methods](09.-Denormalizer-Methods.md#denormalizer-methods) \
[10. Normalizer Methods](10.-Normalizer-Methods.md#normalizer-methods) \
[11. Method Dependencies](11.-Method-Dependencies.md#method-dependencies) \
[12. RegExp Extractors](12.-RegExp-Extractors.md#regular-expression-extractors) \
[13. Serialized Argument](13.-Serialized-Argument.md#serialized-argument) \
[14. Consistency](14.-Consistency.md#consistency) \
[15. Scenarios](15.-Scenarios.md#scenarios) \
[16. Interfaces and Abstract Classes](16.-Interfaces-and-Abstract-Classes.md#interfaces-and-abstract-classes) \
[17. Context](17.-Context.md#context)

# Collections

VOM can process several types of collections, like native arrays or ArrayObject (including doctrine collections), basically any iterable that can be detected as such by the `PropertyInfoExtractor`.
To tell VOM what types sit in a collection you have to add PhpDoc tags and use the [phpdoc array or collection syntax](https://symfony.com/doc/current/components/property_info.html#type-iscollection) as shown in the following example.

## Denormalize a Collection

If you want to pass the `denormalize()` method an array, it is required to pass the array syntax for the model.

```php
$data = [
    'valueCollection' [
        [
            'value' => 'I am the value'
        ],
        [
            'value' => 'I am another value'
        ]
    ]
];

$person = $objectMapper->denormalize($collectionOfPeople, RootClass::class.'[]');
$person = $objectMapper->denormalize($collectionOfPeople, 'RootClass[]');
```

## Native Array Collections

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class RootClass
{
    // for a native array, use the array syntax
    /** @var Thing[] */
    #[VOM\Property]
    public array $valueCollection;
}

#[VOM\Model]
class Thing
{
    #[VOM\Property]
    public string $value;
}
```

## ArrayAccess Collections

For all collections that implement `ArrayAccess` the model preferably should have adder and remover methods and the collection should be initialized in the constructor.

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class RootClass
{    
    // for ArrayAccess, use the collection syntax
    /** @var ArrayObject<Thing> */
    #[VOM\Property]
    private ArrayAccess $things;
    
    public function __construct()
    {
        $this->things = new ArrayObject();
    }
    
    public function addThing(Thing $thing): void
    {
        $this->things->append($thing);
    }
    
    public function removeThing(Thing $thing): void
    {
        // remove it from the ArrayAccess
    }
}
```

If you don't need to add or remove single collection items, and in your use-case it is acceptable to overwrite potentially existing items,
a simpler option is to create a mutator method that accepts an array.

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class RootClass
{    
    /** @var ArrayObject<Thing> */
    #[VOM\Property]
    private ArrayAccess $things;
    
    public function setThings(array $things): void
    {
        $this->things = new ArrayObject($things);
    }
}
```

## Doctrine Collections

If you are working with symfony and create doctrine entities using the maker-bundle, all of this will be generated automatically. The following example is only here to show the extra `VOM\Model` and `VOM\Property` attributes you have to add.
You don't even need to add the `@var` PhpDoc for the collection value type because VOM can determine it by looking at the doctrine entity associations.

```php
use Doctrine\ORM\Mapping as ORM;
use Zolex\VOM\Mapping as VOM;

#[ORM\Entity()]
#[VOM\Model]
class DoctrineAddress
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    #[VOM\Property]
    private ?int $id = null;

    #[ORM\Column(length: 255)]
    #[VOM\Property]
    private ?string $street = null;
}
```

```php
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Zolex\VOM\Mapping as VOM;

#[ORM\Entity]
#[VOM\Model]
class DoctrinePerson
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    #[VOM\Property]
    private ?int $id = null;

    #[ORM\Column(length: 255)]
    #[VOM\Property]
    private ?string $name = null;

    #[ORM\OneToMany(targetEntity: DoctrineAddress::class)]
    #[VOM\Property]
    private Collection $addresses;

    public function __construct()
    {
        $this->addresses = new ArrayCollection();
    }

    public function addAddress(DoctrineAddress $address): void
    {
        if (!$this->addresses->contains($address)) {
            $this->addresses->add($address);
        }
    }

    public function removeAddress(DoctrineAddress $address): void
    {
        $this->addresses->removeElement($address);
    }
}
```

## Collection of Collections

It is also possible to define properties that are collections which contain further levels of collections.

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class CollectionOfCollections
{
    // an array of arrays
    /** @var array[] */
    #[VOM\Property]
    public array $array;

    // a collection of an array of DateAndTime models
    /** @var \ArrayObject<DateAndTime[]> */
    #[VOM\Property]
    public \ArrayAccess $collection;
}

#[VOM\Model]
class DateAndTime
{
    #[VOM\Property]
    public \DateTime $dateTime;
}
```

With the above configuration you can pass VOM the following data structure for denormalization.

```php
$data = [
    'array' => [
        [1, 2, 3],
        [4, 5, 6],
    ],
    'collection' => [
        [
            ['dateTime' => '2011-05-15 10:11:12'],
            ['dateTime' => '2012-06-16 10:11:12'],
        ],
        [
            ['dateTime' => '2013-07-15 10:11:12'],
            ['dateTime' => '2014-08-15 10:11:12'],
        ],
    ],
];

$collection = self::$serializer->denormalize($data, CollectionOfCollections::class);
```

## Accessor-List Collections

If you need to create a collection where each item is supposed to be populated using an individual accessor, accessor-list collections can be used. This feature works with all types of collections: Native arrays, ArrayObject collections and doctrine collections.

```php
$data = [
    'SOME_VALUE' => 42,
    'ANOTHER_VALUE => 1337
    'LAST' => [
        'VALUE' => 3886,
    ],
];
```

To utilize an accessor-list, simply provide an array of accessors in the `accessor` argument of the #[VOM\Property]. Each Item will be wrapped in a value-object containing the properties.

```php
#[VOM\Model]
class AccessorListCollection
{
    /** @var Item[] */
    #[VOM\Property(accessor: [
        '[SOME_VALUE]',
        '[ANOTHER_VALUE ]',
        '[LAST][VALUE]',
    ])]
    public array $list;
}
```

An item that is contained by an Accessor-List Collection is wrapped into a value-object. The actual value can be retrieved using the `value` acccessor.

```php
#[VOM\Model]
class Item
{
    #[VOM\Property(accessor: 'value')
    public int $number; 
}
```

### Accessor-List with discriminator property

If you need to differentiate between the collection items depending on the used accessor, you can provide an associate array with discriminator keys in the `accessor` argument.

```php
#[VOM\Model]
class AccessorListCollection
{
    /** @var Item[] */
    #[VOM\Property(accessor: [
        'type1' => '[SOME_VALUE]',
        'type2' => '[ANOTHER_VALUE ]',
        'type3' => '[LAST][VALUE]',
    ])]
    public array $list;
}
```

The discriminator key can then be retrieved using the `key` accessor of the collection item.

```php
#[VOM\Model]
class Item
{
    #[VOM\Property(accessor: 'key')
    public string $discriminator; 

    #[VOM\Property(accessor: 'value')
    public int $number; 
}
```

### Accessor-List with Accessor-Mapping

Alternatively to the discriminator key, you can differentiate between the collection items using the actual item's accessor.

```php
#[VOM\Model]
class AccessorListCollection
{
    /** @var Item[] */
    #[VOM\Property(accessor: [
        '[SOME_VALUE]',
        '[ANOTHER_VALUE ]',
        '[LAST][VALUE]',
    ])]
    public array $list;
}
```

For example, the item's accessor itself can be used together with the property's map argument to determine a discriminator.

```php
#[VOM\Model]
class Item
{
    #[VOM\Property(accessor: 'accessor', map: [
        '[SOME_VALUE]' => 'type1',
        '[ANOTHER_VALUE ]' => 'type2',
        '[LAST][VALUE]' => 'type3',
    ])
    public string $discriminator; 

    #[VOM\Property(accessor: 'value')
    public int $number; 
}
```

\
\
Continue reading - [07. Constructor Arguments](07.-Constructor-Arguments.md)