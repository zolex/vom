[![Release](https://github.com/zolex/vom/workflows/Release/badge.svg)](https://github.com/zolex/vom/actions/workflows/release.yaml)
[![Version](https://img.shields.io/packagist/v/zolex/vom)](https://packagist.org/packages/zolex/vom)
[![Integration](https://github.com/zolex/vom/workflows/Integration/badge.svg)](https://github.com/zolex/vom/actions/workflows/integration.yaml)
[![Code Coverage](https://codecov.io/gh/zolex/vom/graph/badge.svg?token=RI2NX4S89I)](https://codecov.io/gh/zolex/vom)
[![License](https://img.shields.io/packagist/l/zolex/vom)](./LICENSE)
[![Downloads](https://img.shields.io/packagist/dt/zolex/vom)](https://packagist.org/packages/zolex/vom)

![VOM](https://raw.githubusercontent.com/zolex/vom/refs/heads/master/docs/logo.png)

![PHP](https://img.shields.io/badge/php-%23777BB4.svg?style=for-the-badge&logo=php&logoColor=white)
![Symfony](https://img.shields.io/badge/symfony-%23000000.svg?style=for-the-badge&logo=symfony&logoColor=white)
![Laravel](https://img.shields.io/badge/laravel-%23FF2D20.svg?style=for-the-badge&logo=laravel&logoColor=white)


The Versatile Object Mapper - or in short VOM - is a PHP library to transform any data structure into strictly typed models (and back) by adding PHP 8 attributes.
It extends symfony/serializer functionality and is heavily inspired by doctrine and API-Platform, so that advanced mappings can simply be defined on the model classes instead of writing normalizer decorators.

## Topic Overview

[00. Installation and Integration](00.-Installation-and-Integration.md#installation-and-integration) \
[01. The ObjectMapper](01.-The-Object-Mapper.md#the-object-mapper) \
[02. Property Attribute](02.-Property-Attribute.md#the-property-attribute) \
[03. Disable Nesting](03.-Disable-Nesting.md#disable-nesting) \
[04. Root and Relative Accessor](04.-Root-and-Relative-Accessor.md#root-and-relative-accessor) \
[05. Data Types](05.-Data-Types.md#data-types) \
[06. Collections](06.-Collections.md#collections) \
[07. Constructor Arguments](07.-Constructor-Arguments.md#constructor-arguments) \
[08. Factories](08.-Factories.md#factories) \
[09. Denormalizer Methods](09.-Denormalizer-Methods.md#denormalizer-methods) \
[10. Normalizer Methods](10.-Normalizer-Methods.md#normalizer-methods) \
[11. Method Dependencies](11.-Method-Dependencies.md#method-dependencies) \
[12. RegExp Extractors](12.-RegExp-Extractors.md#regular-expression-extractors) \
[13. Serialized Argument](13.-Serialized-Argument.md#serialized-argument) \
[14. Consistency](14.-Consistency.md#consistency) \
[15. Scenarios](15.-Scenarios.md#scenarios) \
[16. Interfaces and Abstract Classes](16.-Interfaces-and-Abstract-Classes.md#interfaces-and-abstract-classes) \
[17. Context](17.-Context.md#context)

# Scenarios

If there is more than one representation of your normalized data, the `scenario` argument allows to switch between different mappings.

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class ModelWithScenarios
{
    #[VOM\Property]
    #[VOM\Property('[FIRST_NAME]', scenario: 'second')]
    #[VOM\Property('[name][first]'), scenario: 'third'])]
    public string $firstName;
    
    #[VOM\Property]
    #[VOM\Property('[LAST_NAME]', scenario: 'second')]
    #[VOM\Property('[name][last]'), scenario: 'third'])]
    public string $lastName;
}
```

The scenario can be passed in the context of the `serialize`, `deserialize`, `normalize` and `denormalize` methods of the ObjectMapper.

```php
$data = [
    'firstName' => 'Peter',
    'lastName' => 'Parker'
];
$objectMapper->denormalize($data, ModelWithScenarios::class);
```

```php
$data = [
    'FIRST_NAME' => 'Peter',
    'LAST_NAME' => 'Parker'
];
$objectMapper->denormalize($data, ModelWithScenarios::class, null, ['scenario' => 'second']);
```

```php
$data = [
    'name' => [
        'first' => 'Peter',
        'last' => 'Parker'
    ]
];
$objectMapper->denormalize($data, ModelWithScenarios::class, null, ['scenario' => 'third']);
```

The `scenario` argument can also be used on the arguments of constructors, factories and denormalizers as well as on normalizer methods.

## Constructor Scenarios

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class ModelWithScenarios
{
    public function __construct(
      #[VOM\Argument]
      #[VOM\Argument('[FIRST_NAME]', scenario: 'second')]
      string $firstName,
      
      #[VOM\Argument]
      #[VOM\Argument('[LAST_NAME]', scenario: 'second')]
      string $lastName,
    ) {
        // ...
    }
}
```

## Factory Scenarios

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class ModelWithScenarios
{
    #[VOM\Factory]
    public function create(
      #[VOM\Argument]
      #[VOM\Argument('[FIRST_NAME]', scenario: 'second')]
      string $firstName,
      
      #[VOM\Argument]
      #[VOM\Argument('[LAST_NAME]', scenario: 'second')]
      string $lastName,
    ): self {
        // ...
    }
}
```

## Denormalizer Scenarios

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class ModelWithScenarios
{
    #[VOM\Denormalizer]
    public function denormalizeValues(
      #[VOM\Argument]
      #[VOM\Argument('[FIRST_NAME]', scenario: 'second')]
      string $firstName,
      
      #[VOM\Argument]
      #[VOM\Argument('[LAST_NAME]', scenario: 'second')]
      string $lastName,
    ) {
        // ...
    }
}
```

## Normalizer Scenarios

```php
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class ModelWithScenarios
{
    private string $firstName = 'Peter';
    private string $lastName = 'Parker';

    #[VOM\Normalizer(accessor: '[firstName]')]
    public function normalizeFirstNameForDefaultScenario(): string {
        return $this->firstName;
    }
    
    #[VOM\Normalizer(accessor: '[FIRST_NAME]', scenario: 'second')]
    public function normalizeFirstNameForSecondScenario(): string {
        return strtoupper($this->firstName);
    }
    
    #[VOM\Normalizer(accessor: '[lastName]')]
    public function normalizeLastNameForDefaultScenario(): string {
        return return $this->lastName;
    }
    
    #[VOM\Normalizer(accessor: '[LAST_NAME]', scenario: 'second')]
    public function normalizeFirstNameForSecondScenario(): string {
        return strtoupper($this->lastName);
    }
}
```

## Scenarios with Groups

For fine-grained control, scenarios can also be combined with the `Groups` feature.

```php
use \Symfony\Component\Serializer\Attribute\Groups;
use Zolex\VOM\Mapping as VOM;

#[VOM\Model]
class ModelWithScenarios
{
    private string $firstName = 'Peter';
    private string $lastName = 'Parker';

    #[Groups('firstname')]
    #[VOM\Normalizer(accessor: '[firstName]')]
    public function getFirstNameForDefaultScenario(): string {
        return $this->firstName;
    }
    
    #[Groups('firstname')]
    #[VOM\Normalizer(accessor: '[FIRST_NAME]', scenario: 'second')]
    public function getFirstNameForSecondScenario(): string {
        return strtoupper($this->firstName);
    }
    
    #[Groups('lastname')]
    #[VOM\Normalizer(accessor: '[lastName]')]
    public function getLastNameForDefaultScenario(): string {
        return return $this->lastName;
    }
    
    #[Groups('lastname')]
    #[VOM\Normalizer(accessor: '[LAST_NAME]', scenario: 'second')]
    public function getFirstNameForSecondScenario(): string {
       return strtoupper($this->lastName);
    }
}
``` 

\
\
Continue reading - [16. Interfaces and Abstract Classes](16.-Interfaces-and-Abstract-Classes.md)