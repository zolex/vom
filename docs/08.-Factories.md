[![Release](https://github.com/zolex/vom/workflows/Release/badge.svg)](https://github.com/zolex/vom/actions/workflows/release.yaml)
[![Version](https://img.shields.io/packagist/v/zolex/vom)](https://packagist.org/packages/zolex/vom)
[![Integration](https://github.com/zolex/vom/workflows/Integration/badge.svg)](https://github.com/zolex/vom/actions/workflows/integration.yaml)
[![Code Coverage](https://codecov.io/gh/zolex/vom/graph/badge.svg?token=RI2NX4S89I)](https://codecov.io/gh/zolex/vom)
[![License](https://img.shields.io/packagist/l/zolex/vom)](./LICENSE)
[![Downloads](https://img.shields.io/packagist/dt/zolex/vom)](https://packagist.org/packages/zolex/vom)

![VOM](https://raw.githubusercontent.com/zolex/vom/refs/heads/master/docs/logo.png)

![PHP](https://img.shields.io/badge/php-%23777BB4.svg?style=for-the-badge&logo=php&logoColor=white)
![Symfony](https://img.shields.io/badge/symfony-%23000000.svg?style=for-the-badge&logo=symfony&logoColor=white)
![Laravel](https://img.shields.io/badge/laravel-%23FF2D20.svg?style=for-the-badge&logo=laravel&logoColor=white)


The Versatile Object Mapper - or in short VOM - is a PHP library to transform any data structure into strictly typed models (and back) by adding PHP 8 attributes.
It extends symfony/serializer functionality and is heavily inspired by doctrine and API-Platform, so that advanced mappings can simply be defined on the model classes instead of writing normalizer decorators.

## Topic Overview

[00. Installation and Integration](00.-Installation-and-Integration.md#installation-and-integration) \
[01. The ObjectMapper](01.-The-Object-Mapper.md#the-object-mapper) \
[02. Property Attribute](02.-Property-Attribute.md#the-property-attribute) \
[03. Disable Nesting](03.-Disable-Nesting.md#disable-nesting) \
[04. Root and Relative Accessor](04.-Root-and-Relative-Accessor.md#root-and-relative-accessor) \
[05. Data Types](05.-Data-Types.md#data-types) \
[06. Collections](06.-Collections.md#collections) \
[07. Constructor Arguments](07.-Constructor-Arguments.md#constructor-arguments) \
[08. Factories](08.-Factories.md#factories) \
[09. Denormalizer Methods](09.-Denormalizer-Methods.md#denormalizer-methods) \
[10. Normalizer Methods](10.-Normalizer-Methods.md#normalizer-methods) \
[11. Method Dependencies](11.-Method-Dependencies.md#method-dependencies) \
[12. RegExp Extractors](12.-RegExp-Extractors.md#regular-expression-extractors) \
[13. Serialized Argument](13.-Serialized-Argument.md#serialized-argument) \
[14. Consistency](14.-Consistency.md#consistency) \
[15. Scenarios](15.-Scenarios.md#scenarios) \
[16. Interfaces and Abstract Classes](16.-Interfaces-and-Abstract-Classes.md#interfaces-and-abstract-classes) \
[17. Context](17.-Context.md#context)

# Factories

## Factory Methods

An alternative to injecting values in the model's constructor, it is also possible to configure factory methods on the model using the `VOM\Factory` together with the `VOM\Argument` attributes.

```php
#[VOM\Model]
class ModelWithFactory
{
    private string $modelName;
    private string|int $modelGroup;

    private function __construct()
    {
    }

    #[VOM\Factory]
    public static function create(
        #[VOM\Argument]
        string $name,
        #[VOM\Argument]
        string|int|null $group
    ): self {
        $instance = new self();
        $instance->setModelName($name);
        if (null !== $group) {
            $instance->setModelGroup($group);
        }

        return $instance;
    }
    
    public function setModelName(string $name): void
    {
        $this->modelName = $name;
    }
    
    public function setModelGroup(string|int $group): void
    {
        $this->mdoelGroup = $group;
    }
}
```

In the case that your source data is inconsistent and/or your model is instantiable with different sets of required properties, you can provide multiple factories that VOM will try to instantiate your model with.
Optionally you can provide a priority for each factory, the higher the value, the earlier VOM with call it. If no priority is given, the order of appearance in the code is used. The first successful factory method wins.

```php
#[VOM\Model]
class ModelWithFactory
{
    #[VOM\Factory]
    public static function createWithSetOne(/* ... */): self
    {
        // ...
    }
    
    #[VOM\Factory(priority: 100)]
    public static function createWithSetTwo(/* ... */): self
    {
        // ...
    }
}
```

## Factory in another class

It is also possible to create a factory in another class, for example in a (Doctrine) repository.

```php
#[VOM\Model(factory: [RepositoryWithFactory::class, 'createModelInstance'])]
class ModelWithCallableFactory
{
    // ...
}
```

```php
class RepositoryWithFactory
{
    public static function createModelInstance(
        #[VOM\Argument]
        string $name,
        #[VOM\Argument]
        string|int|null $group = null,
    ): ModelWithCallableFactory {
        $model = new ModelWithCallableFactory();
        $model->setName($name);
        if (null !== $group) {
            $model->setGroup($group);
        }

        return $model;
    }
}
```
\
\
Continue reading - [09. Denormalizer Methods](09.-Denormalizer-Methods.md)